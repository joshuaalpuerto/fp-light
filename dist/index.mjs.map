{"version":3,"file":"index.mjs","sources":["../src/not.js","../src/complement.js","../src/identity.js","../src/curry.js","../src/ifElse.js","../src/when.js","../src/reduce.js"],"sourcesContent":["/**\n * Returns the negate result of calling argument\n * TODO: work on signature, make this curry function\n * @param {*} predicate \n * @param {*} trueFn \n */\nconst not = (arg) =>\n  !arg\n\n\nexport default not","import not from './not'\n/**\n * Returns the negate result of the calling function\n * TODO: work on signature, make this curry function\n * @param {*} predicate \n * @param {*} trueFn \n */\nconst complement = (fn) => (...args) =>\n  not(fn(...args))\n\n\nexport default complement","/**\n * A function that returns the same value\n * Why since identity function acts like a neutral value in functions \n * Just like 0 to number. where it doesn't return value\n * This is very useful in HOF wehere we just ned the value\n * @param {*} val \n */\nconst identity = (val) => val\nexport default identity","/**\n * Returns a curried equivalent of the provided function. First, its arguments needn't be provided one\n * at a time. the\n * following are equivalent:\n *\n *   - `g(1)(2)(3)`\n *   - `g(1)(2, 3)`\n *   - `g(1, 2)(3)`\n *   - `g(1, 2, 3)`\n *   - `g()()(1, 2, 3)`\n */\nfunction curry (fns) {\n  return function curried(...args) {\n    return args.length >= fns.length ? fns.apply(this, args)  : curried.bind(null, ...args);\n  }\n}\n\nexport default curry","import curry from './curry'\n/**\n * Returns function that if predicate is evaluate correctly \n * will evaluate the true statement else evaluate the false.\n * TODO: work on signature, make this curry function\n * @param {*} predicate \n * @param {*} truthy \n * @param {*} falsy \n */\nconst ifElse = (predicate, truthy, falsy, args) =>\n  predicate(args) ? truthy(args) : falsy(args)\n\n\nexport default curry(ifElse)","import curry from './curry'\n/**\n * Returns function that if predicate is evaluated true  \n * then will return the whenTrueFn given the same argument otherwise will just return the argument as is.\n * TODO: work on signature, make this curry function\n * @param {*} predicate \n * @param {*} trueFn \n */\nconst when = (predicate, trueFn, args) =>\n  predicate(args) ? trueFn(args) : args\n\n\nexport default curry(when)","import curry from './curry'\n/**\n * Returns a single item by iterating through the list, successively calling\n * the iterator function and passing it an accumulator value and the current\n * value from the array, and then passing the result to the next call.\n * \n * @param {Function} fn The iterator function. Receives two values, the accumulator and the\n *        current element from the array.\n * @param {*} acc The accumulator value.\n * @param {Array} list The list to iterate over.\n * @return {*} The final, accumulated value.\n **/\n// TODO: need to put this inside the curry function but we are running issue with closure.\nconst reduce = (fn, acc, list) => list.reduce(fn, acc)\n\nexport default curry(reduce)"],"names":["const","not","arg","complement","fn","args","identity","val","curry","fns","curried","length","apply","this","bind","predicate","truthy","falsy","trueFn","acc","list","reduce"],"mappings":"AAMAA,IAAMC,WAAOC,UACVA,GCAGC,WAAcC,mFAClBH,EAAIG,aAAG,EAAGC,MCDNC,WAAYC,UAAQA,GCI1B,SAASC,EAAOC,UACP,SAASC,kEACPL,EAAKM,QAAUF,EAAIE,OAASF,EAAIG,MAAMC,KAAMR,GAASK,EAAQI,cAAK,aAAST,KCJtFL,MAIeQ,WAJCO,EAAWC,EAAQC,EAAOZ,UACxCU,EAAUV,GAAQW,EAAOX,GAAQY,EAAMZ,OCE1BG,WAJDO,EAAWG,EAAQb,UAC/BU,EAAUV,GAAQa,EAAOb,GAAQA,MCMpBG,WAFCJ,EAAIe,EAAKC,UAASA,EAAKC,OAAOjB,EAAIe"}