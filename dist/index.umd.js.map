{"version":3,"file":"index.umd.js","sources":["../src/not.js","../src/curry.js","../src/ifElse.js","../src/when.js","../src/reduce.js","../src/complement.js","../src/identity.js"],"sourcesContent":["/**\n * Returns the negate result of calling argument\n * TODO: work on signature, make this curry function\n * @param {*} predicate \n * @param {*} trueFn \n */\nconst not = (arg) =>\n  !arg\n\n\nexport default not","/**\n * Returns a curried equivalent of the provided function. First, its arguments needn't be provided one\n * at a time. the\n * following are equivalent:\n *\n *   - `g(1)(2)(3)`\n *   - `g(1)(2, 3)`\n *   - `g(1, 2)(3)`\n *   - `g(1, 2, 3)`\n *   - `g()()(1, 2, 3)`\n */\nfunction curry (fns) {\n  return function curried(...args) {\n    return args.length >= fns.length ? fns.apply(this, args)  : curried.bind(null, ...args);\n  }\n}\n\nexport default curry","import curry from './curry'\n/**\n * Returns function that if predicate is evaluate correctly \n * will evaluate the true statement else evaluate the false.\n * TODO: work on signature, make this curry function\n * @param {*} predicate \n * @param {*} truthy \n * @param {*} falsy \n */\nconst ifElse = (predicate, truthy, falsy, args) =>\n  predicate(args) ? truthy(args) : falsy(args)\n\n\nexport default curry(ifElse)","import curry from './curry'\n/**\n * Returns function that if predicate is evaluated true  \n * then will return the whenTrueFn given the same argument otherwise will just return the argument as is.\n * TODO: work on signature, make this curry function\n * @param {*} predicate \n * @param {*} trueFn \n */\nconst when = (predicate, trueFn, args) =>\n  predicate(args) ? trueFn(args) : args\n\n\nexport default curry(when)","import curry from './curry'\n/**\n * Returns a single item by iterating through the list, successively calling\n * the iterator function and passing it an accumulator value and the current\n * value from the array, and then passing the result to the next call.\n * \n * @param {Function} fn The iterator function. Receives two values, the accumulator and the\n *        current element from the array.\n * @param {*} acc The accumulator value.\n * @param {Array} list The list to iterate over.\n * @return {*} The final, accumulated value.\n **/\n// TODO: need to put this inside the curry function but we are running issue with closure.\nconst reduce = (fn, acc, list) => list.reduce(fn, acc)\n\nexport default curry(reduce)","import not from './not'\n/**\n * Returns the negate result of the calling function\n * TODO: work on signature, make this curry function\n * @param {*} predicate \n * @param {*} trueFn \n */\nconst complement = (fn) => (...args) =>\n  not(fn(...args))\n\n\nexport default complement","/**\n * A function that returns the same value\n * Why since identity function acts like a neutral value in functions \n * Just like 0 to number. where it doesn't return value\n * This is very useful in HOF wehere we just ned the value\n * @param {*} val \n */\nconst identity = (val) => val\nexport default identity"],"names":["const","not","arg","curry","fns","curried","args","length","apply","this","bind","predicate","truthy","falsy","trueFn","fn","acc","list","reduce","val"],"mappings":"6KAMAA,IAAMC,WAAOC,UACVA,GCIH,SAASC,EAAOC,UACP,SAASC,kEACPC,EAAKC,QAAUH,EAAIG,OAASH,EAAII,MAAMC,KAAMH,GAASD,EAAQK,cAAK,aAASJ,KCJtFN,MAIeG,WAJCQ,EAAWC,EAAQC,EAAOP,UACxCK,EAAUL,GAAQM,EAAON,GAAQO,EAAMP,OCE1BH,WAJDQ,EAAWG,EAAQR,UAC/BK,EAAUL,GAAQQ,EAAOR,GAAQA,MCMpBH,WAFCY,EAAIC,EAAKC,UAASA,EAAKC,OAAOH,EAAIC,2BCN9BD,mFAClBd,EAAIc,aAAG,EAAGT,0BCDMa,UAAQA"}